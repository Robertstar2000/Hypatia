

import React, { useState, useEffect } from 'react';
import { useExperiment } from '../../../services';
import { useToast } from '../../../toast';
import { parseGeminiError, callGeminiWithRetry } from '../../../services';
import { DYNAMIC_TABLE_SCHEMA } from '../../../config';
import * as XLSX from 'xlsx';

export const ManualDataEntry = ({ onComplete, context }) => {
    const { gemini } = useExperiment();
    const [columns, setColumns] = useState<string[]>([]);
    const [rows, setRows] = useState<Record<string, string>[]>([]);
    const [isInitializing, setIsInitializing] = useState(true);
    const { addToast } = useToast();

    useEffect(() => {
        if (gemini) {
            const prompt = `Based on the data collection plan summary: "${context.data_collection_plan_summary}", generate a JSON array of objects. Each object should represent a column for a data entry table and have two keys: "columnName" (string) and "dataType" (string, e.g., 'number', 'string'). For example: [{"columnName": "time_seconds", "dataType": "number"}, {"columnName": "temperature_celsius", "dataType": "number"}]. Output only the raw JSON array.`;
            callGeminiWithRetry(gemini, 'gemini-2.5-flash', { contents: prompt, config: { responseMimeType: "application/json", responseSchema: DYNAMIC_TABLE_SCHEMA } })
                .then(response => {
                    const schemaArray = JSON.parse(response.text);
                    if (!Array.isArray(schemaArray)) throw new Error("AI response was not a JSON array.");
                    const newColumns = schemaArray.map(col => col.columnName);
                    
                    setColumns(newColumns);
                    setRows([Object.fromEntries(newColumns.map(c => [c, '']))]);
                })
                .catch(err => {
                    addToast(parseGeminiError(err, "AI failed to create a data entry form."), "danger");
                    setColumns(['Column 1', 'Column 2']);
                    setRows([{'Column 1': '', 'Column 2': ''}]);
                })
                .finally(() => setIsInitializing(false));
        }
    }, [gemini, context, addToast]);

    const handleRowChange = (index, col, value) => {
        const newRows = [...rows];
        newRows[index][col] = value;
        setRows(newRows);
    };

    const addRow = () => setRows([...rows, Object.fromEntries(columns.map(c => [c, '']))]);
    const removeRow = (index) => setRows(rows.filter((_, i) => i !== index));

    const handleSubmit = () => {
        const header = columns.join(',');
        const body = rows.map(row => columns.map(col => `"${(row[col] || '').replace(/"/g, '""')}"`).join(',')).join('\n');
        const csvData = `${header}\n${body}`;
        onComplete(csvData, "Manually entered data.");
    };

    const handleDownloadTemplate = () => {
        if (columns.length === 0) {
            addToast("Columns are still being generated by the AI.", "warning");
            return;
        }
        // Create a worksheet with only the headers
        const ws = XLSX.utils.aoa_to_sheet([columns]);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "Data Entry");
        
        // Auto-size columns for better readability
        const wscols = columns.map(col => ({ wch: col.length + 5 })); // Add some padding
        ws['!cols'] = wscols;

        XLSX.writeFile(wb, "Data_Entry_Template.xlsx");
        addToast("Excel template downloaded.", "success");
    };

    if (isInitializing) return <div className="text-center p-4"><div className="spinner-border"></div><p className="mt-2">AI is building your data entry form...</p></div>;

    return (
        <div>
            <div className="card mb-4">
                <div className="card-body">
                    <h6 className="fw-bold">Option 1: Use the Web Form</h6>
                    <p className="small text-white-50 mb-3">Enter your data directly into the table below. The form was generated by the AI based on your data collection plan.</p>
                    <div className="table-responsive">
                        <table className="table table-bordered">
                            <thead><tr>{columns.map(c => <th key={c}>{c}</th>)}<th>Actions</th></tr></thead>
                            <tbody>
                                {rows.map((row, rowIndex) => (
                                    <tr key={rowIndex}>
                                        {columns.map(col => <td key={col}><input type="text" className="form-control form-control-sm" value={row[col] || ''} onChange={e => handleRowChange(rowIndex, col, e.target.value)} /></td>)}
                                        <td><button className="btn btn-sm btn-outline-danger" onClick={() => removeRow(rowIndex)} disabled={rows.length <= 1}><i className="bi bi-trash"></i></button></td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                    <button className="btn btn-secondary me-2" onClick={addRow}><i className="bi bi-plus-lg me-1"></i> Add Row</button>
                    <button className="btn btn-success" onClick={handleSubmit}><i className="bi bi-check-circle-fill me-1"></i> Submit Data from Form</button>
                </div>
            </div>
            
            <div className="card">
                <div className="card-body">
                     <h6 className="fw-bold">Option 2: Use an Excel Template</h6>
                     <p className="small text-white-50 mb-3">For larger datasets, download a pre-formatted Excel template. After filling it out, go back and use the "Upload Your Data" mode to submit it.</p>
                     <button className="btn btn-info" onClick={handleDownloadTemplate} disabled={columns.length === 0}>
                         <i className="bi bi-file-earmark-excel-fill me-1"></i> Download Data Entry Template (.xlsx)
                     </button>
                 </div>
            </div>
        </div>
    );
};